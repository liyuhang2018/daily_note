# python

## python带\_的变量或函数命名

### 前后均带有双下划线\_\_的命名

```python
一般用于特殊方法的命名，用来实现对象的一些行为或者功能，比如__new__()方法用来创建实例，__init__()方法用来初始化对象，

x + y操作被映射为方法x.__add__(y)，序列或者字典的索引操作x[k]映射为x.__getitem__(k)，__len__()、__str__()分别被内置函数len()、str()调用等等。
```

### 仅开头带双下划线\_\_的命名

```text
用于对象的数据封装，以此命名的属性或者方法为类的私有属性或者私有方法。

class Foo(object):
    def __init__(self):
        self.__name = 'private name'

    def getname(self):
        return self.__name

    def __spam(self):
        print 'private method'

    def bar(self):
        self.__spam()
如果在外部直接访问私有属性或者方法：

>>> f = Foo()
>>> f.__name

Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    f.__name
AttributeError: 'Foo' object has no attribute '__name'
>>> f.__spam()

Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    f.__spam()
AttributeError: 'Foo' object has no attribute '__spam'
是不可行的，这就起到了隐藏数据的作用，但是这种实现机制并不是很严格，机制是通过自动"变形"实现的，类中所有以双下划线开头的名称__name都会自动变为"_类名__name"的新名称：

>>> f._Foo__name
'private name'
>>> f._Foo__spam()
private method
这样就可以访问了。

这种机制可以阻止继承类重新定义或者更改方法的实现，比如，定义一个Foo的派生类：

class Goo(Foo):
    def __spam(self):
        print 'private method of Goo'
重写了__spam方法，运行：

>>> g = Goo()
>>> g.bar()
private method
调用bar()方法的时候依然执行的是Foo类的__spam()方法，因为在bar()方法的实现中，self.__spam()已自动变形为self._Foo__spam(),Goo继承的bar()方法也是如此。
```

### 以单下划线\_开头的命名

```text
一般用于模块中的"私有"定义的命名。

from module import * 语句用于加载模块中的所有名称，要控制导入的名称，一种方法是定义列表__all__，只有在__all__中的名称才能通过*导入，

另一种方法就是以单下划线开头命名定义了，这种定义不会被*导入。

当然，在类中也可以用单下划线开头来命名属性或者方法，这只是表示类的定义者希望这些属性或者方法是"私有的"，但实际上并不会起任何作用。
```

## copy模块

[index](https://www.cnblogs.com/linxiyue/p/7970287.html)

```python
list(),dict(),set()，切片都是浅拷贝
浅复制中，复制的新对象中包含的是对原始对象中的项的引用，如果对象的项为可变对象，也会产生不可控行为：

深复制将创建一个新对象，并递归地复制它所包含的所有对象。
```

## random模块

### shuffle\(\) //洗牌

```python
# 对于一个元素的列表洗牌
import random
random.shuffle(list)
```

## matplotlib

### pyplot

#### 同时画二个图     //设置图片线宽度，线格式

```python
import matplotlib.pyplot as plt
import numpy as np
x = np.linspace(-3,3,50)
y1 = 2 * x +1
y2 = x ** 2
plt.figure()   #开启画布
plt.plot(x,y1,linewidth = 1.0,linestyle='--')
#linewidth 画出的线的宽度,linestyle为虚线

plt.figure(num = 3 ,figsize = (8,5))   ##num = 3就是窗口叫figure3，figsize为x，y上下限
plt.plot(x,y2,color = 'red')

plt.show()
#如果这样的话，显示的是二个窗口，一个窗口显示一个曲线
#如果只创建一个画布，就用一个画布来显示二个曲线
```

### xlabel ylabel   //设置标签名称

```python
plt.xlabel('123')
```

#### xlim,ylim   //设置plt的x上下限，y上下限

```python
plt.xlim((-1,2))
plt.ylim((-2,3))
```

#### xticks,yticks  //设置坐标之间间隔，将坐标换成字符

```python
plt.xticks(np.linspace(-1,2,5))
plt.yticks([-2,-1.8],['really bad','bad'])   将y坐标换成字符串
```

## numpy模块

### 关于numpy的加减乘除

```python
a= np.array([[1,2],[3,4]])
a + 2    # [[3,4],[5,6]]  相当于把+2扩展成+[[2,2],[2,2]] 
a / [1,2]  #[[1,1],[3,2]] 相当于把[1,2]扩展成[[1,2],[1,2]]
```

### np.random

#### np.random.normal\(\)

```python
生成正态分布的数或者数组
np.random.normal(loc = 0.0,scale = 1.0 , size = None)
#上述为不赋值时的标准值
np.random.normal(0,1,(2,2))  #array([[-2.12708511,  1.25274321], [ 0.93498906, -0.45805673]])
```

#### np.random.randn\(\) // 生成随机numpy数组

```python
import numpy as np
np.random.randn(6,4)
#生成一个6×4二维的numpy数组
np.random.randn(5)
#生成一个一维数组
#生成数组为默认的0为均值，1为标准差的正态分布
```

#### np.random.randint\(\)

```python
np.random.randint(-5,5,size=(2,2))
array([[ 2, -1],
       [ 2,  0]])
```

#### np.random.uniform\(\)

```python
np.random.uniform()
#生成一个0到1之间的值
np.random.uniform(1,2,(5,5))
#生成1个1到2,5乘以5的矩阵
```

### np.arange\(\) //生成numpy线性数组

```python
#一个参数 默认起点0，步长为1 输出：[0 1 2]
a = np.arange(3)

#两个参数 默认步长为1 输出[3 4 5 6 7 8]
a = np.arange(3,9)

#三个参数 起点为0，终点为4，步长为0.1 输出[ 0.   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1.   1.1  1.2  1.3  1.4 1.5  1.6  1.7  1.8  1.9  2.   2.1  2.2  2.3  2.4  2.5  2.6  2.7  2.8  2.9]
a = np.arange(0, 3, 0.1)
```

### np.argmax\(\)    //输出列表中最大的index

```python
a = [1,2,3]
np.argmax(a)
2
```

### np.linalg.inv\(\)   //numpy矩阵求逆

```python
import numpy as np
a  = np.array([[1, 2], [3, 4]])
print(np.linalg.inv)
#矩阵还可以通过.I来求矩阵
A = np.matrix(a)
print(A.I)
```

### np.dot\(\) //计算向量或者矩阵的乘积

```python
import numpy as np

np.dot(3,4)
12

np.dot([1,2,3],[4,5,6])
32
#知识点：对于一维数组，其结果等于两向量的内积：设向量 a=(x1,y1)，向量b=(x2,y2)，结果等于x1*x2+y1*y2
a = np.array([[1,2],[3,4],[2,5]])
b = np.array([[2,3,1],[4,5,2]])
np.dot(a,b)
array([[10, 13,  5],
       [22, 29, 11],
a、b都是二维数组，相当于矩阵的乘法
```

### np.linspace  //生成线性的数组

```python
np.linspace(5,6,10)
#output:array([5., 5.11111111, 5.22222222, 5.33333333, 5.44444444, 5.55555556, 5.66666667, 5.77777778, 5.88888889, 6.])
```

### np.meshgird\(\)

```python
二维坐标系中,X轴可以取三个值1,2,3, Y轴可以取三个值7,8, 请问可以获得多少个点的坐标?
显而易见是6个:
(1,7)(2,7)(3,7)
(1,8)(2,8)(3,8)

np.meshgrid()就是干这个的!

#coding:utf-8
import numpy as np
# 坐标向量
a = np.array([1,2,3])
# 坐标向量
b = np.array([7,8])
# 从坐标向量中返回坐标矩阵
# 返回list,有两个元素,第一个元素是X轴的取值,第二个元素是Y轴的取值
res = np.meshgrid(a,b)
#返回结果: [array([ [1,2,3] [1,2,3] ]), array([ [7,7,7] [8,8,8] ])]
```

### np.reshape\(\)

```python
import numpy as np
a = np.array([2,3],[4,5])
a.reshape((1,4)) #[1,2,3,4]
```

## os模块

getpid\(\) //获得进程进行的唯一编号

## sys模块

### sys.argv //获取命令行个数

```text
python test.py arg1 arg2 arg3
那么sys.argv = ['test.py','arg1','arg2','arg3']
```

### sys.path

#### sys.path.append

```python
import sys
sys.path.append(r'your_path') 
#动态的添加库路径。在程序运行过程中修改sys.path的值，添加自己的库路径
```

## pandas模块

### DataFrame模块

data\[列名\] //由dataframe生成一个series序列

#### data.info\(\)  //dataframe　详情

```python
<class 'pandas.core.frame.DataFrame'>
DatetimeIndex: 29 entries, 2015-01-01 to 2015-02-01
Data columns (total 10 columns):
百合酱蒸凤爪     29 non-null int64
翡翠蒸香茜饺     29 non-null int64
金银蒜汁蒸排骨    29 non-null int64
乐膳真味鸡      29 non-null int64
蜜汁焗餐包      28 non-null float64
生炒菜心       29 non-null int64
铁板酸菜豆腐     29 non-null int64
香煎韭菜饺      29 non-null int64
香煎罗卜糕      29 non-null int64
原汁原味菜心     29 non-null int64
dtypes: float64(1), int64(9)
memory usage: 2.5 KB
```

#### data.iloc

```python
#selection by label
df.iloc['20130101']
df.iloc['20130101':'20130103']
df.iloc[:,'A']
df.iloc[:,'A':'C']
```

#### data.loc

```python
#selection by position
df.iloc[0:3]
df.iloc[:,2]
df.iloc[:,2:3]
```

### series   //默认series是data

#### data.cumsum\(\)   ///积累值

```python
菜品名
A1     9173
A2     5729
A3     4811
A4     3594
A5     3195
A6     3026
A7     2378
A8     1970
A9     1877
A10    1782
Name: 盈利, dtype: int64

after data.cumsum()
菜品名
A1      9173
A2     14902
A3     19713
A4     23307
A5     26502
A6     29528
A7     31906
A8     33876
A9     35753
A10    37535
Name: 盈利, dtype: int64
```

#### data.sort\_values\(ascending=False\)　//对series进行排序

```python
按照series的大小对数据进行重组排序
A10    1782
A9     1877
A8     1970
A7     2378
A6     3026
A5     3195
A4     3594
A3     4811
A2     5729
A1     9173
```

#### data.sum\(\)  //生成一个series列的总和,

```python
生成一个series列的总和,得到的值为一个数值
```

## python基础模块

### class

#### 从当前文件夹导入模块

```python
from Abc import *
# 切记，Abc.py是一个py文件，首字母一定要大写
from Abc.abc import *
# Abc为文件夹，首字母一定要大写，abc.py不一定要大写
```

#### 导入其它文件

```text
切记，其它文件里面的函数，类用的是自己定义的常量和函数，并不是调用他函数的那个文件的常量，函数
```

### join

```python
seq = ("a", "b", "c")
' '.join(seq)
输出a-b-c
```

### property  //装饰器

```python
@property
考察 Student 类：

class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
当我们想要修改一个 Student 的 scroe 属性时，可以这么写：

s = Student('Bob', 59)
s.score = 60
但是也可以这么写：

s.score = 1000
显然，直接给属性赋值无法检查分数的有效性。

如果利用两个方法：

class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.__score = score
    def get_score(self):
        return self.__score
    def set_score(self, score):
        if score < 0 or score > 100:
            raise ValueError('invalid score')
        self.__score = score
这样一来，s.set_score(1000) 就会报错。

这种使用 get/set 方法来封装对一个属性的访问在许多面向对象编程的语言中都很常见。

但是写 s.get_score() 和 s.set_score() 没有直接写 s.score 来得直接。

有没有两全其美的方法？----有。

因为Python支持高阶函数，在函数式编程中我们介绍了装饰器函数，可以用装饰器函数把 get/set 方法“装饰”成属性调用：

class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.__score = score
    @property
    def score(self):
        return self.__score
    @score.setter
    def score(self, score):
        if score < 0 or score > 100:
            raise ValueError('invalid score')
        self.__score = score
注意: 第一个score(self)是get方法，用@property装饰，第二个score(self, score)是set方法，用@score.setter装饰，@score.setter是前一个@property装饰后的副产品。

现在，就可以像使用属性一样设置score了：

>>> s = Student('Bob', 59)
>>> s.score = 60
>>> print s.score
60
>>> s.score = 1000
Traceback (most recent call last):
  ...
ValueError: invalid score
说明对 score 赋值实际调用的是 set方法。

任务
如果没有定义set方法，就不能对“属性”赋值，这时，就可以创建一个只读“属性”。

请给Student类加一个grade属性，根据 score 计算 A（>=80）、B、C（<60）。
```

### set操作

```text
创建集合set
python set类是在python的sets模块中，大家现在使用的python2.7.x中，不需要导入sets模块可以直接创建集合。
>>>set('boy')
set(['y', 'b', 'o'])

集合添加、删除
python 集合的添加有两种常用方法，分别是add和update。
集合add方法：是把要传入的元素做为一个整个添加到集合中，例如：
>>> a = set('boy')
>>> a.add('python')
>>> a
set(['y', 'python', 'b', 'o'])

#　在学习python的朋友们，强烈推荐加入 Python QQ群。

集合update方法：是把要传入的元素拆分，做为个体传入到集合中，例如：
>>> a = set('boy')
>>> a.update('python')
>>> a
set(['b', 'h', 'o', 'n', 'p', 't', 'y'])

集合删除操作方法：remove
set(['y', 'python', 'b', 'o'])
>>> a.remove('python')
>>> a
set(['y', 'b', 'o'])




python set() 集合操作符号、数学符号
-:差集   &:交集   |:并集   ==:等于  !=:不等于  in:成员关系  not in:不是成员关系
```

### string

#### split //字符串转化成数组

```python
a = '123'
a.split('2')  #输出['1','3']
```

### 常见问题

#### Python 中 （&，\|）和（and，or）之间的区别

如果a，b是数值变量， 则&， \|表示位运算， and，or则依据是否非0来决定输出，

```text
# 1&2，2在二进制里面是10,1在二进制中是01，那么01与运算10得到是0 


1 & 2         # 输出为 0， 
1 | 2          # 输出为3


 # 判断变量是否为0， 是0则为False，非0判断为True，
 # and中含0，返回0； 均为非0时，返回后一个值， 
2 and 0   # 返回0
2 and 1   # 返回1
1 and 2   # 返回2

# or中， 至少有一个非0时，返回第一个非0,
2 or 0   # 返回2
2 or 1   # 返回2
0 or 1   # 返回1
```

如果a, b是逻辑变量， 则两类的用法基本一致

```text
In[103]:(3>0) | (3<1)
Out[103]: True
In[104]:(3>0) and (3<1)
Out[104]: False
In[105]:(3>0) or (3<1)
Out[105]: True
In[106]:(3>0) & (3<1)
Out[106]: False
```

#### 集合的交并

```python
>>> a=[1,2,3]
>>> b=[1,3,4]
>>> set(a) & set(b)
{1, 3}
>>> set(a) | set(b)
{1, 2, 3, 4}
>>> c=len(a)
```

## jupyter notebook

### 一些快捷键

```python
#代码直接执行shift+回车
#查看语句的具体作用shift + ｔａｂ
```

## tensorflow

### graph

#### tf.placeholder

```python
placeholder()函数是在神经网络构建graph的时候在模型中的占位，此时并没有把要输入的数据传入模型，它只会分配必要的内存。等建立session，在会话中，运行模型的时候通过feed_dict()函数向占位符喂入数据。

演示代码:

import tensorflow as tf
import numpy as np

input1 = tf.placeholder(tf.float32)
input2 = tf.placeholder(tf.float32)

output = tf.multiply(input1, input2)

with tf.Session() as sess:
    print sess.run(output, feed_dict = {input1:[3.], input2: [4.]})
```

