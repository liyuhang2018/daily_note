# python常用文档

## random模块

### shuffle() //洗牌

```python
# 对于一个元素的列表洗牌
import random
random.shuffle(list)
```



## numpy模块

###　关于numpy的加减乘除

```python
a= np.array([[1,2],[3,4]])
a + 2    # [[3,4],[5,6]]  相当于把+2扩展成+[[2,2],[2,2]] 
a / [1,2]  #[[1,1],[3,2]] 相当于把[1,2]扩展成[[1,2],[1,2]]
```

### np.random

#### np.random.normal()

```python
生成正态分布的数或者数组
np.random.normal(loc = 0.0,scale = 1.0 , size = None)
#上述为不赋值时的标准值
np.random.normal(0,1,(2,2))  #array([[-2.12708511,  1.25274321], [ 0.93498906, -0.45805673]])

```





#### np.random.randn() // 生成随机numpy数组

```python
import numpy as np
np.random.randn(6,4)
#生成一个6×4二维的numpy数组
np.random.randn(5)
#生成一个一维数组
#生成数组为默认的0为均值，1为标准差的正态分布
```

#### np.random.randint()

```python
np.random.randint(-5,5,size=(2,2))
array([[ 2, -1],
       [ 2,  0]])
```

#### np.random.uniform()

```python
np.random.uniform()
#生成一个0到1之间的值
np.random.uniform(1,2,(5,5))
#生成1个1到2,5乘以5的矩阵
```

### np.arange() //生成numpy线性数组

```python
#一个参数 默认起点0，步长为1 输出：[0 1 2]
a = np.arange(3)

#两个参数 默认步长为1 输出[3 4 5 6 7 8]
a = np.arange(3,9)

#三个参数 起点为0，终点为4，步长为0.1 输出[ 0.   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1.   1.1  1.2  1.3  1.4 1.5  1.6  1.7  1.8  1.9  2.   2.1  2.2  2.3  2.4  2.5  2.6  2.7  2.8  2.9]
a = np.arange(0, 3, 0.1)
```

### np.argmax()    //输出列表中最大的index

```python
a = [1,2,3]
np.argmax(a)
2
```



### np.linalg.inv()   //numpy矩阵求逆

```python
import numpy as np
a  = np.array([[1, 2], [3, 4]])
print(np.linalg.inv)
#矩阵还可以通过.I来求矩阵
A = np.matrix(a)
print(A.I)
```

### np.dot() //计算向量或者矩阵的乘积

```python
import numpy as np
 
np.dot(3,4)
12
 
np.dot([1,2,3],[4,5,6])
32
#知识点：对于一维数组，其结果等于两向量的内积：设向量 a=(x1,y1)，向量b=(x2,y2)，结果等于x1*x2+y1*y2
a = np.array([[1,2],[3,4],[2,5]])
b = np.array([[2,3,1],[4,5,2]])
np.dot(a,b)
array([[10, 13,  5],
       [22, 29, 11],
a、b都是二维数组，相当于矩阵的乘法
```

### np.linspace  //生成线性的数组

```python
np.linspace(5,6,10)
#output:array([5., 5.11111111, 5.22222222, 5.33333333, 5.44444444, 5.55555556, 5.66666667, 5.77777778, 5.88888889, 6.])
```

### np.reshape()

```python
import numpy as np
a = np.array([2,3],[4,5])
a.reshape((1,4)) #[1,2,3,4]
```





## os模块

### getpid()   //获得进程进行的唯一编号

## sys模块

### sys.path

#### sys.path.append

```python
import sys
sys.path.append(r'your_path') 
#动态的添加库路径。在程序运行过程中修改sys.path的值，添加自己的库路径
```





## pandas模块

### DataFrame模块

#### iloc 

```python
#selection by label
df.iloc['20130101']
df.iloc['20130101':'20130103']
df.iloc[:,'A']
df.iloc[:,'A':'C']
```

#### loc

```python
#selection by position
df.iloc[0:3]
df.iloc[:,2]
df.iloc[:,2:3]
```





## python基础模块

### class

#### 从当前文件夹导入模块

```python
from Abc import *
# 切记，Abc.py是一个py文件，首字母一定要大写
from Abc.abc import *
# Abc为文件夹，首字母一定要大写，abc.py不一定要大写
```

#### 导入其它文件

```
切记，其它文件里面的函数，类用的是自己定义的常量和函数，并不是调用他函数的那个文件的常量，函数
```

### 集合的交并

```python
>>> a=[1,2,3]
>>> b=[1,3,4]
>>> set(a) & set(b)
{1, 3}
>>> set(a) | set(b)
{1, 2, 3, 4}
>>> c=len(a)
```

## jupyter notebook

### 一些快捷键

```python
#代码直接执行shift+回车
#查看语句的具体作用shift + ｔａｂ
```

## tensorflow

### graph

#### tf.placeholder

```python
placeholder()函数是在神经网络构建graph的时候在模型中的占位，此时并没有把要输入的数据传入模型，它只会分配必要的内存。等建立session，在会话中，运行模型的时候通过feed_dict()函数向占位符喂入数据。

演示代码:
    
import tensorflow as tf
import numpy as np
 
input1 = tf.placeholder(tf.float32)
input2 = tf.placeholder(tf.float32)
 
output = tf.multiply(input1, input2)
 
with tf.Session() as sess:
    print sess.run(output, feed_dict = {input1:[3.], input2: [4.]})
    
```







