# c++

## c程序内存管理

### 代码区

```text
存放函数体的二进制代码
```

### 数据区

```text
文字常量，全局变量，静态常量
```

### 堆

```text
程序员动态开辟的空间，超出后申请更多，地址空间可能不连续
```

### 栈

```text
大小固定，压栈，弹栈操作由编译器负责，一旦用完将报错
```

### c++函数执行过程

```text
返回地址先入栈，各个参数入栈，函数局部变量入栈,函数内部定义的静态变量不入栈
```

### c++类所占空间

[index](http://www.cnblogs.com/pipicfan/archive/2012/06/20/2556213.html)

```text
一）类内部的成员变量：

普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
（二）类内部的成员函数：

普通函数：不占用内存。
虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的
```

## c++变量

### 静态全局变量

```text
1、静态局部变量和普通局部变量不同。静态局部变量也是定义在函数内部的，静态局部变量定义时前面要加static关键字来标识，静态局部变量所在的函数在多调用多次时，只有第一次才经历变量定义和初始化，以后多次在调用时不再定义和初始化，而是维持之前上一次调用时执行后这个变量的值。本次接着来使用。

2、静态局部变量在第一次函数被调用时创造并初始化，但在函数退出时它不死亡，而是保持其值等待函数下一次被调用。下次调用时不再重新创造和初始化该变量，而是直接用上一次留下的值为基础来进行操作。

3、静态局部变量的这种特性，和全局变量非常类似。它们的相同点是都创造和初始化一次，以后调用时值保持上次的不变。不同点在于作用域不同
```

### 普通全局变量，静态全局变量和跨文件引用的全局变量

```text
全局变量 定义在函数外面的变量，就叫全局变量。

普通全局变量  普通全局变量就是平时使用的，定义前不加任何修饰词。普通全局变量可以在各个文件中使 用，可以在项目内别的.c文件中被看到，所以要确保不能重名。

静态全局变量  静态全局变量就是用来解决重名问题的。静态全局变量定义时在定义前加static关键字， 告诉编译器这个变量只在当前本文件内使用，在别的文件中绝对不会使用。这样就不用担心重名问题。所以静态的全局变量就用在我定义这个全局变量并不是为了给别的文件使用，本来就是给我这个文件自己使用的。

跨文件引用全局变量(extern) 就是说，你在一个程序的多个.c源文件中，可以在一个.c文件中定义全局变量g_a,并且可以在别的另一个.c文件中引用该变量g_a（引用前要声明）

函数和全局变量在C语言中可以跨文件引用，也就是说他们的连接范围是全局的，具有文件连接属性，总之意思就是全局变量和函数是可以跨文件看到的（直接影响就是，我在a.c和b.c中各自定义了一个函数func，名字相同但是内容不同，编译报错。）。
```

### 局部变量和全局变量的对比

```text
1、定义同时没有初始化，则局部变量的值是随机的，而全局变量的值是默认为0.
2、使用范围上：全局变量具有文件作用域，而局部变量只有代码块作用域。
3、生命周期上：全局变量是在程序开始运行之前的初始化阶段就诞生，到整个程序结束退出的时候才死亡；而局部变量在进入局部变量所在的代码块时诞生，在该代码块退出的时候死亡。
4、变量分配位置：全局变量分配在数据段上，而局部变量分配在栈上。
```

## c++函数

### 关于函数后面加const

```cpp
编译器会自动给每一个函数加一个this指针。在一个类的函数后面加上const后，就表明这个函数是不能改变类的成员变量的（加了mutable修饰的除外,后面有讲）。实际上，也就是对这个this指针加上了const修饰。

int Person::getAge() const{
    this->age = 23;      // wrong: want to modify data member, the compiler will report error
    return this->age;
```

### 虚函数，纯虚函数

```text
１.　C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。
子类可以重写父类的虚函数实现子类的特殊化

2.纯虚函数(pure virtual)　//virtual void out1(string s)=0;函数后面加上等于０，是纯虚函数
　　C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
　　C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。
　　C++中的纯虚函数也是一种“运行时多态”。
　　如下面的类包含纯虚函数，就是“抽象类”：
```

## stl

### string

#### string.substr\(\)    //截取字符串子串

```text
string x="Hello_World";
    /*默认截取从0到npos.重载原型为string substr(_off=0,_count=npos);npos一般表示为string类中不存在的位置,_off表示字符串的开始位置，_count截取的字符的数目*/
    cout<<x.substr()<<endl;
    cout<<x.substr(5)<<endl;//截取x[5]到结尾，即npos.重载原型为string substr(_off,_count=npos)
    cout<<x.substr(0,5)<<endl;//以x[0]为始，向后截取5位（包含x[0]），重载原型string substr(_off,_count)
    /*
    备注：
    指定的截取长度加起始位置即_off+_count>源字符串的长度，则子字符串将延续到源字符串的结尾
    */
```

### map

#### map基本操作

```text
1，map简介

map是STL的一个关联容器，它提供一对一的hash。

第一个可以称为关键字(key)，每个关键字只能在map中出现一次；
第二个可能称为该关键字的值(value)；

map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。



2，map的功能

自动建立key － value的对应。key 和 value可以是任意你需要的类型。

3，使用map

使用map得包含map类所在的头文件

#include <map>  //注意，STL头文件没有扩展名.h

map对象是模板类，需要关键字和存储对象两个模板参数：

std:map<int, string> personnel;

这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.

为了使用方便，可以对模板类进行一下类型定义，

typedef map<int,CString> UDT_MAP_INT_CSTRING;

UDT_MAP_INT_CSTRING enumMap;

4.map的构造函数

map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：

map<int, string> mapStudent;

5，插入元素

// 定义一个map对象
map<int, string> mapStudent;

// 第一种 用insert函數插入pair
mapStudent.insert(pair<int, string>(000, "student_zero"));

// 第二种 用insert函数插入value_type数据
mapStudent.insert(map<int, string>::value_type(001, "student_one"));

// 第三种 用"array"方式插入
mapStudent[123] = "student_first";
mapStudent[456] = "student_second";
以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：

mapStudent.insert(map<int, string>::value_type (001, "student_one"));

mapStudent.insert(map<int, string>::value_type (001, "student_two"));
上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下

// 构造定义，返回一个pair对象
pair<iterator,bool> insert (const value_type& val);

pair<map<int, string>::iterator, bool> Insert_Pair;

Insert_Pair = mapStudent.insert(map<int, string>::value_type (001, "student_one"));

if(!Insert_Pair.second)
    cout << ""Error insert new element" << endl;
我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。

6， 查找元素

当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。

// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置
iter = mapStudent.find("123");

if(iter != mapStudent.end())
       cout<<"Find, the value is"<<iter->second<<endl;
else
   cout<<"Do not Find"<<endl;
7， 刪除与清空元素

//迭代器刪除
iter = mapStudent.find("123");
mapStudent.erase(iter);

//用关键字刪除
int n = mapStudent.erase("123"); //如果刪除了會返回1，否則返回0

//用迭代器范围刪除 : 把整个map清空
mapStudent.erase(mapStudent.begin(), mapStudent.end());
//等同于mapStudent.clear()
8，map的大小

在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：

int nSize = mapStudent.size();


 9，map的基本操作函数：

     C++ maps是一种关联式容器，包含“关键字/值”对

     begin()         返回指向map头部的迭代器

     clear(）        删除所有元素

     count()         返回指定元素出现的次数

     empty()         如果map为空则返回true

     end()           返回指向map末尾的迭代器

     equal_range()   返回特殊条目的迭代器对

     erase()         删除一个元素

     find()          查找一个元素

     get_allocator() 返回map的配置器

     insert()        插入元素

     key_comp()      返回比较元素key的函数

     lower_bound()   返回键值>=给定元素的第一个位置

     max_size()      返回可以容纳的最大元素个数

     rbegin()        返回一个指向map尾部的逆向迭代器

     rend()          返回一个指向map头部的逆向迭代器

     size()          返回map中元素的个数

     swap()           交换两个map

     upper_bound()    返回键值>给定元素的第一个位置

     value_comp()     返回比较元素value的函数
```

## c++类

### 构造函数

```text
构造函数可以不返回值
```

### 友元friend

[链接](https://www.cnblogs.com/honeybusybee/p/5259265.html)

```text
一个函数可以同时是二个类的友元，一个类也可以是其它类的友元
```

### this指针

```text
比如class A {
public void method（）{
A.this就是表示A的对象。。在这种情况下和this是一样的
}
class B {
void method1() {
A.this还是表示A的对象。。但是这里是在内部类里面。。所以这里的this就是内部类B的对象了。。但是我们经常会在内部类里面调用外部的东西。。所以就用A.this这种方式就行了
```

## c++基础

### char

#### char指针

```cpp
#include <stdio.h>  
#include <stdlib.h>  

int main(void){  
    char *a="bcd";  
    printf("输出字符：%c /n", *a);  /*输出字符，使用"%c"*/<br>    printf("输出字符：%c /n", *(a+1) );  /*输出字符，使用"%c"*/  
    printf("输出字符串：%s /n", a); /*输出字符串，使用"%s"；而且a之前不能有星号"*"  */   
    system("pause");  /*为了能看到输出结果*/  
}  
/*运行结果如下： 
输出字符：b<br>输出字符：c 
输出字符串：bcd*/  

//输出%s,字符串的时候，传入的是地址，不是值
```

### char定义以及后面\0

```text
1）字符数组方式初始化大致3种：

(1)   char str[10]="12345"或者char str[10]={'1','2','3','4','5'};

       这种方式初始化，系统会自动从未初始化的元素开始，将之后的元素赋为结束标志‘\0’。如上面str数组中的元素实际上是{'1','2','3','4','5','\0','\0','\0','\0','\0'}。

(2)   char str[]="12345";

        这种初始化方式，系统会自动在字符串末尾加上结束标志‘\0’。

(3)   char str[]={'1','2','3','4','5'};

        这种初始化方式，系统不会自动在字符串末尾加上结束标志‘\0’。此时，可以使用关键字sizeof()可以正确求出其所占内存的大小；但用strlen()不能正确求出其长度，因为strlen函数是通过'\0'判断字符串结束的。所以，采用此种方式初始化时，一般人为的加上'\0'，如 char str[]={'1','2','3','4','5','\0'}。
```

### c++取整

```text
1、直接赋值给整数变量。如：
    int i = 2.5; 或 i = (int) 2.5;
    这种方法采用的是舍去小数部分
2、C/C++中的整数除法运算符“/”本身就有取整功能(int / int)，而下面介绍的取整函数返回值是double。整数除法对正数的取整是舍去小数部分，可以用于你的问题。但是整数除法对负数的取整结果和使用的C编译器有关。
3、使用floor函数。floor(x)返回的是小于或等于x的最大整数。如：
    floor(2.5) = 2
    floor(-2.5) = -3
4、使用ceil函数。ceil(x)返回的是大于x的最小整数。如：
    ceil(2.5) = 3
    ceil(-2.5) = -2
    floor()是向负无穷大舍入，floor(-2.5) = -3；ceil()是向正无穷大舍入
```

### c++重载

[index](https://blog.csdn.net/liitdar/article/details/80654324)

```text
operator 是C++的一个关键字，它和运算符（如=）一起使用，表示一个运算符重载函数，在理解时可将operator和运算符（如operator=）视为一个函数名。

使用operator重载运算符，是C++扩展运算符功能的方法。使用operator扩展运算符功能的原因如下：

使重载后的运算符的使用方法与重载前一致
扩展运算符的功能只能通过函数的方式实现（实际上，C++中各种“功能”都是由函数实现的）
```

### c++argc,argv

```text
int main (int argc char *argv[])
argc是指执行时参数的个数，程序名算一个参数。
argv是一个数组
```

### c++ &&和\|\|的区别

```text
在c/c++中的&和|是位运算符，和它们处于相同地位的还有<<、>>、^、~。这两个运算符会使得参与运算的参数的每一位都进行运算。例如10和6相与，即1010&0110,得0010，也就是2.

但是&&和||却是逻辑运算符，在它们看来，除了0之外，其他的非零整数都可以看做true，所以如果10和6相与，结果会是true。

有的时候会发现在使用&&的地方可以使用&来替代。在大多数情况下确实都是可以的。这是因为在使用&&的时候，两侧如果都是非0值，那么结果就是true，而在使用&的时候进行相与运算，得到的结果一般也是这样，但是也会有偶然情况：例如10和5相与，即1010&0101，则结果为0，这时候的结果就是不一样的。

总之，它们两个是不一样的。

而且在使用&&的时候，如果第一个就是false，那么就不会再计算第二个参数，因为不管怎样，结果都会是false。这个被称为短路，对于||也是同样的。

总结一下：

&&是逻辑运算符，&是位运算符，在有些时候&&可以被&替代，但是这只能算作巧合。

另外&&还可以短路，在第一个参数是false的情况下，就会发生短路。||在第一个参数是true的情况下，也会发生短路。
```

