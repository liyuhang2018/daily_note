# c++

## c程序内存管理

### 代码区

### 数据区

```
文字常量，全局变量，静态常量
```

### 堆

```
程序员动态开辟的空间，超出后申请更多，地址空间可能不连续
```

### 栈

```
大小固定，压栈，弹栈操作由编译器负责，一旦用完将报错
```

##　ｃ＋＋函数执行过程

```
返回地址先入栈，各个参数入栈，函数局部变量入栈,函数内部定义的静态变量不入栈
```

## c++变量

### 静态全局变量

```
1、静态局部变量和普通局部变量不同。静态局部变量也是定义在函数内部的，静态局部变量定义时前面要加static关键字来标识，静态局部变量所在的函数在多调用多次时，只有第一次才经历变量定义和初始化，以后多次在调用时不再定义和初始化，而是维持之前上一次调用时执行后这个变量的值。本次接着来使用。

2、静态局部变量在第一次函数被调用时创造并初始化，但在函数退出时它不死亡，而是保持其值等待函数下一次被调用。下次调用时不再重新创造和初始化该变量，而是直接用上一次留下的值为基础来进行操作。

3、静态局部变量的这种特性，和全局变量非常类似。它们的相同点是都创造和初始化一次，以后调用时值保持上次的不变。不同点在于作用域不同
```

### 普通全局变量，静态全局变量和夸文件引用的全局变量

```
全局变量 定义在函数外面的变量，就叫全局变量。

普通全局变量  普通全局变量就是平时使用的，定义前不加任何修饰词。普通全局变量可以在各个文件中使 用，可以在项目内别的.c文件中被看到，所以要确保不能重名。

静态全局变量  静态全局变量就是用来解决重名问题的。静态全局变量定义时在定义前加static关键字， 告诉编译器这个变量只在当前本文件内使用，在别的文件中绝对不会使用。这样就不用担心重名问题。所以静态的全局变量就用在我定义这个全局变量并不是为了给别的文件使用，本来就是给我这个文件自己使用的。

跨文件引用全局变量(extern) 就是说，你在一个程序的多个.c源文件中，可以在一个.c文件中定义全局变量g_a,并且可以在别的另一个.c文件中引用该变量g_a（引用前要声明）

函数和全局变量在C语言中可以跨文件引用，也就是说他们的连接范围是全局的，具有文件连接属性，总之意思就是全局变量和函数是可以跨文件看到的（直接影响就是，我在a.c和b.c中各自定义了一个函数func，名字相同但是内容不同，编译报错。）。
```

### 局部变量和全局变量的对比

```
1、定义同时没有初始化，则局部变量的值是随机的，而全局变量的值是默认为0.
2、使用范围上：全局变量具有文件作用域，而局部变量只有代码块作用域。
3、生命周期上：全局变量是在程序开始运行之前的初始化阶段就诞生，到整个程序结束退出的时候才死亡；而局部变量在进入局部变量所在的代码块时诞生，在该代码块退出的时候死亡。
4、变量分配位置：全局变量分配在数据段上，而局部变量分配在栈上。
```

## c++函数

### 关于函数后面加const

```c++
编译器会自动给每一个函数加一个this指针。在一个类的函数后面加上const后，就表明这个函数是不能改变类的成员变量的（加了mutable修饰的除外,后面有讲）。实际上，也就是对这个this指针加上了const修饰。

int Person::getAge() const{
    this->age = 23;      // wrong: want to modify data member, the compiler will report error
    return this->age;


```

### 虚函数，纯虚函数

```
１.　C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。
子类可以重写父类的虚函数实现子类的特殊化

2.纯虚函数(pure virtual)　//virtual void out1(string s)=0;函数后面加上等于０，是纯虚函数
　　C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
　　C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。
　　C++中的纯虚函数也是一种“运行时多态”。
　　如下面的类包含纯虚函数，就是“抽象类”：
```





## stl

### string

#### string.substr()    //截取字符串子串

```
string x="Hello_World";
    /*默认截取从0到npos.重载原型为string substr(_off=0,_count=npos);npos一般表示为string类中不存在的位置,_off表示字符串的开始位置，_count截取的字符的数目*/
    cout<<x.substr()<<endl;
    cout<<x.substr(5)<<endl;//截取x[5]到结尾，即npos.重载原型为string substr(_off,_count=npos)
    cout<<x.substr(0,5)<<endl;//以x[0]为始，向后截取5位（包含x[0]），重载原型string substr(_off,_count)
    /*
    备注：
    指定的截取长度加起始位置即_off+_count>源字符串的长度，则子字符串将延续到源字符串的结尾
    */
```

### map

#### map基本操作

```
1，map简介

map是STL的一个关联容器，它提供一对一的hash。

第一个可以称为关键字(key)，每个关键字只能在map中出现一次；
第二个可能称为该关键字的值(value)；

map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。



2，map的功能

自动建立key － value的对应。key 和 value可以是任意你需要的类型。

3，使用map

使用map得包含map类所在的头文件

#include <map>  //注意，STL头文件没有扩展名.h

map对象是模板类，需要关键字和存储对象两个模板参数：

std:map<int, string> personnel;

这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.

为了使用方便，可以对模板类进行一下类型定义，

typedef map<int,CString> UDT_MAP_INT_CSTRING;

UDT_MAP_INT_CSTRING enumMap;

4，map的构造函数

map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：

map<int, string> mapStudent;

5，插入元素

// 定义一个map对象
map<int, string> mapStudent;
 
// 第一种 用insert函數插入pair
mapStudent.insert(pair<int, string>(000, "student_zero"));
 
// 第二种 用insert函数插入value_type数据
mapStudent.insert(map<int, string>::value_type(001, "student_one"));
 
// 第三种 用"array"方式插入
mapStudent[123] = "student_first";
mapStudent[456] = "student_second";
以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：

mapStudent.insert(map<int, string>::value_type (001, "student_one"));
 
mapStudent.insert(map<int, string>::value_type (001, "student_two"));
上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下

// 构造定义，返回一个pair对象
pair<iterator,bool> insert (const value_type& val);
 
pair<map<int, string>::iterator, bool> Insert_Pair;
 
Insert_Pair = mapStudent.insert(map<int, string>::value_type (001, "student_one"));
 
if(!Insert_Pair.second)
    cout << ""Error insert new element" << endl;
我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。

6， 查找元素

当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。

// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置
iter = mapStudent.find("123");
 
if(iter != mapStudent.end())
       cout<<"Find, the value is"<<iter->second<<endl;
else
   cout<<"Do not Find"<<endl;
7， 刪除与清空元素

//迭代器刪除
iter = mapStudent.find("123");
mapStudent.erase(iter);
 
//用关键字刪除
int n = mapStudent.erase("123"); //如果刪除了會返回1，否則返回0
 
//用迭代器范围刪除 : 把整个map清空
mapStudent.erase(mapStudent.begin(), mapStudent.end());
//等同于mapStudent.clear()
8，map的大小

在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：

int nSize = mapStudent.size();
 

 9，map的基本操作函数：

     C++ maps是一种关联式容器，包含“关键字/值”对

     begin()         返回指向map头部的迭代器

     clear(）        删除所有元素

     count()         返回指定元素出现的次数

     empty()         如果map为空则返回true

     end()           返回指向map末尾的迭代器

     equal_range()   返回特殊条目的迭代器对

     erase()         删除一个元素

     find()          查找一个元素

     get_allocator() 返回map的配置器

     insert()        插入元素

     key_comp()      返回比较元素key的函数

     lower_bound()   返回键值>=给定元素的第一个位置

     max_size()      返回可以容纳的最大元素个数

     rbegin()        返回一个指向map尾部的逆向迭代器

     rend()          返回一个指向map头部的逆向迭代器

     size()          返回map中元素的个数

     swap()           交换两个map

     upper_bound()    返回键值>给定元素的第一个位置

     value_comp()     返回比较元素value的函数
```



## c++类

### 构造函数

```
构造函数可以不返回值
```

## c++基础

### c++取整

```
1、直接赋值给整数变量。如：
    int i = 2.5; 或 i = (int) 2.5;
    这种方法采用的是舍去小数部分
2、C/C++中的整数除法运算符“/”本身就有取整功能(int / int)，而下面介绍的取整函数返回值是double。整数除法对正数的取整是舍去小数部分，可以用于你的问题。但是整数除法对负数的取整结果和使用的C编译器有关。
3、使用floor函数。floor(x)返回的是小于或等于x的最大整数。如：
    floor(2.5) = 2
    floor(-2.5) = -3
4、使用ceil函数。ceil(x)返回的是大于x的最小整数。如：
    ceil(2.5) = 3
    ceil(-2.5) = -2
    floor()是向负无穷大舍入，floor(-2.5) = -3；ceil()是向正无穷大舍入
```

