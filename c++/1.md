# c++

## c程序内存管理

### 代码区

```text
存放函数体的二进制代码
```

### 数据区

```text
文字常量，全局变量，静态常量
```

### 堆

```text
程序员动态开辟的空间，超出后申请更多，地址空间可能不连续
```

### 栈

```text
大小固定，压栈，弹栈操作由编译器负责，一旦用完将报错
```

### c++函数执行过程

```text
返回地址先入栈，各个参数入栈，函数局部变量入栈,函数内部定义的静态变量不入栈
```

### c++类所占空间

[index](http://www.cnblogs.com/pipicfan/archive/2012/06/20/2556213.html)

<<<<<<< HEAD
```
（一）类内部的成员变量：
=======
​```text
一）类内部的成员变量：
>>>>>>> 6ad17393954b95d49e823d190bb3a3d0631ccb1e

普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
（二）类内部的成员函数：

普通函数：不占用内存。
虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的
```

## c++变量

### 静态全局变量

```text
1、静态局部变量和普通局部变量不同。静态局部变量也是定义在函数内部的，静态局部变量定义时前面要加static关键字来标识，静态局部变量所在的函数在多调用多次时，只有第一次才经历变量定义和初始化，以后多次在调用时不再定义和初始化，而是维持之前上一次调用时执行后这个变量的值。本次接着来使用。

2、静态局部变量在第一次函数被调用时创造并初始化，但在函数退出时它不死亡，而是保持其值等待函数下一次被调用。下次调用时不再重新创造和初始化该变量，而是直接用上一次留下的值为基础来进行操作。

3、静态局部变量的这种特性，和全局变量非常类似。它们的相同点是都创造和初始化一次，以后调用时值保持上次的不变。不同点在于作用域不同
```

### 普通全局变量，静态全局变量和跨文件引用的全局变量

```text
全局变量 定义在函数外面的变量，就叫全局变量。

普通全局变量  普通全局变量就是平时使用的，定义前不加任何修饰词。普通全局变量可以在各个文件中使 用，可以在项目内别的.c文件中被看到，所以要确保不能重名。

静态全局变量  静态全局变量就是用来解决重名问题的。静态全局变量定义时在定义前加static关键字， 告诉编译器这个变量只在当前本文件内使用，在别的文件中绝对不会使用。这样就不用担心重名问题。所以静态的全局变量就用在我定义这个全局变量并不是为了给别的文件使用，本来就是给我这个文件自己使用的。

跨文件引用全局变量(extern) 就是说，你在一个程序的多个.c源文件中，可以在一个.c文件中定义全局变量g_a,并且可以在别的另一个.c文件中引用该变量g_a（引用前要声明）

函数和全局变量在C语言中可以跨文件引用，也就是说他们的连接范围是全局的，具有文件连接属性，总之意思就是全局变量和函数是可以跨文件看到的（直接影响就是，我在a.c和b.c中各自定义了一个函数func，名字相同但是内容不同，编译报错。）。
```

### 局部变量和全局变量的对比

```text
1、定义同时没有初始化，则局部变量的值是随机的，而全局变量的值是默认为0.
2、使用范围上：全局变量具有文件作用域，而局部变量只有代码块作用域。
3、生命周期上：全局变量是在程序开始运行之前的初始化阶段就诞生，到整个程序结束退出的时候才死亡；而局部变量在进入局部变量所在的代码块时诞生，在该代码块退出的时候死亡。
4、变量分配位置：全局变量分配在数据段上，而局部变量分配在栈上。
```

## c++函数

### 关于函数后面加const

```cpp
编译器会自动给每一个函数加一个this指针。在一个类的函数后面加上const后，就表明这个函数是不能改变类的成员变量的（加了mutable修饰的除外,后面有讲）。实际上，也就是对这个this指针加上了const修饰。

int Person::getAge() const{
    this->age = 23;      // wrong: want to modify data member, the compiler will report error
    return this->age;
```

### 虚函数，纯虚函数

```text
１.　C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。
子类可以重写父类的虚函数实现子类的特殊化

2.纯虚函数(pure virtual)　//virtual void out1(string s)=0;函数后面加上等于０，是纯虚函数
　　C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。
　　C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。
　　C++中的纯虚函数也是一种“运行时多态”。
　　如下面的类包含纯虚函数，就是“抽象类”：
```

## stl

### string

#### string.substr\(\)    //截取字符串子串

```text
string x="Hello_World";
    /*默认截取从0到npos.重载原型为string substr(_off=0,_count=npos);npos一般表示为string类中不存在的位置,_off表示字符串的开始位置，_count截取的字符的数目*/
    cout<<x.substr()<<endl;
    cout<<x.substr(5)<<endl;//截取x[5]到结尾，即npos.重载原型为string substr(_off,_count=npos)
    cout<<x.substr(0,5)<<endl;//以x[0]为始，向后截取5位（包含x[0]），重载原型string substr(_off,_count)
    /*
    备注：
    指定的截取长度加起始位置即_off+_count>源字符串的长度，则子字符串将延续到源字符串的结尾
    */
```

### map

#### map基本操作

```text
1，map简介

map是STL的一个关联容器，它提供一对一的hash。

第一个可以称为关键字(key)，每个关键字只能在map中出现一次；
第二个可能称为该关键字的值(value)；

map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。



2，map的功能

自动建立key － value的对应。key 和 value可以是任意你需要的类型。

3，使用map

使用map得包含map类所在的头文件

#include <map>  //注意，STL头文件没有扩展名.h

map对象是模板类，需要关键字和存储对象两个模板参数：

std:map<int, string> personnel;

这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.

为了使用方便，可以对模板类进行一下类型定义，

typedef map<int,CString> UDT_MAP_INT_CSTRING;

UDT_MAP_INT_CSTRING enumMap;

4.map的构造函数

map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：

map<int, string> mapStudent;

5，插入元素

// 定义一个map对象
map<int, string> mapStudent;

// 第一种 用insert函數插入pair
mapStudent.insert(pair<int, string>(000, "student_zero"));

// 第二种 用insert函数插入value_type数据
mapStudent.insert(map<int, string>::value_type(001, "student_one"));

// 第三种 用"array"方式插入
mapStudent[123] = "student_first";
mapStudent[456] = "student_second";
以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：

mapStudent.insert(map<int, string>::value_type (001, "student_one"));

mapStudent.insert(map<int, string>::value_type (001, "student_two"));
上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下

// 构造定义，返回一个pair对象
pair<iterator,bool> insert (const value_type& val);

pair<map<int, string>::iterator, bool> Insert_Pair;

Insert_Pair = mapStudent.insert(map<int, string>::value_type (001, "student_one"));

if(!Insert_Pair.second)
    cout << ""Error insert new element" << endl;
我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。

6， 查找元素

当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。

// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置
iter = mapStudent.find("123");

if(iter != mapStudent.end())
       cout<<"Find, the value is"<<iter->second<<endl;
else
   cout<<"Do not Find"<<endl;
7， 刪除与清空元素

//迭代器刪除
iter = mapStudent.find("123");
mapStudent.erase(iter);

//用关键字刪除
int n = mapStudent.erase("123"); //如果刪除了會返回1，否則返回0

//用迭代器范围刪除 : 把整个map清空
mapStudent.erase(mapStudent.begin(), mapStudent.end());
//等同于mapStudent.clear()
8，map的大小

在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：

int nSize = mapStudent.size();


 9，map的基本操作函数：

     C++ maps是一种关联式容器，包含“关键字/值”对

     begin()         返回指向map头部的迭代器

     clear(）        删除所有元素

     count()         返回指定元素出现的次数

     empty()         如果map为空则返回true

     end()           返回指向map末尾的迭代器

     equal_range()   返回特殊条目的迭代器对

     erase()         删除一个元素

     find()          查找一个元素

     get_allocator() 返回map的配置器

     insert()        插入元素

     key_comp()      返回比较元素key的函数

     lower_bound()   返回键值>=给定元素的第一个位置

     max_size()      返回可以容纳的最大元素个数

     rbegin()        返回一个指向map尾部的逆向迭代器

     rend()          返回一个指向map头部的逆向迭代器

     size()          返回map中元素的个数

     swap()           交换两个map

     upper_bound()    返回键值>给定元素的第一个位置

     value_comp()     返回比较元素value的函数
```

## c++类

### 构造函数

```text
构造函数可以不返回值
```

### 友元friend

[链接](https://www.cnblogs.com/honeybusybee/p/5259265.html)

```text
一个函数可以同时是二个类的友元，一个类也可以是其它类的友元
```

### this指针

```text
比如class A {
public void method（）{
A.this就是表示A的对象。。在这种情况下和this是一样的
}
class B {
void method1() {
A.this还是表示A的对象。。但是这里是在内部类里面。。所以这里的this就是内部类B的对象了。。但是我们经常会在内部类里面调用外部的东西。。所以就用A.this这种方式就行了
```

## c++基础

### 位运算

1 位逻辑运算符：  

& （位   “与”）  and     

 ^（位   “异或”）

  |   （位    “或”）   or

  ~  （位   “取反”）

2 移位运算符：

​      <<（左移）

​      **>>**（右移

### char

#### char指针

```cpp
#include <stdio.h>  
#include <stdlib.h>  

int main(void){  
    char *a="bcd";  
    printf("输出字符：%c /n", *a);  /*输出字符，使用"%c"*/<br>    printf("输出字符：%c /n", *(a+1) );  /*输出字符，使用"%c"*/  
    printf("输出字符串：%s /n", a); /*输出字符串，使用"%s"；而且a之前不能有星号"*"  */   
    system("pause");  /*为了能看到输出结果*/  
}  
/*运行结果如下： 
输出字符：b<br>输出字符：c 
输出字符串：bcd*/  

//输出%s,字符串的时候，传入的是地址，不是值
```

### char定义以及后面\0

```text
1）字符数组方式初始化大致3种：

(1)   char str[10]="12345"或者char str[10]={'1','2','3','4','5'};

       这种方式初始化，系统会自动从未初始化的元素开始，将之后的元素赋为结束标志‘\0’。如上面str数组中的元素实际上是{'1','2','3','4','5','\0','\0','\0','\0','\0'}。

(2)   char str[]="12345";

        这种初始化方式，系统会自动在字符串末尾加上结束标志‘\0’。

(3)   char str[]={'1','2','3','4','5'};

        这种初始化方式，系统不会自动在字符串末尾加上结束标志‘\0’。此时，可以使用关键字sizeof()可以正确求出其所占内存的大小；但用strlen()不能正确求出其长度，因为strlen函数是通过'\0'判断字符串结束的。所以，采用此种方式初始化时，一般人为的加上'\0'，如 char str[]={'1','2','3','4','5','\0'}。
```

### c++取整

```text
1、直接赋值给整数变量。如：
    int i = 2.5; 或 i = (int) 2.5;
    这种方法采用的是舍去小数部分
2、C/C++中的整数除法运算符“/”本身就有取整功能(int / int)，而下面介绍的取整函数返回值是double。整数除法对正数的取整是舍去小数部分，可以用于你的问题。但是整数除法对负数的取整结果和使用的C编译器有关。
3、使用floor函数。floor(x)返回的是小于或等于x的最大整数。如：
    floor(2.5) = 2
    floor(-2.5) = -3
4、使用ceil函数。ceil(x)返回的是大于x的最小整数。如：
    ceil(2.5) = 3
    ceil(-2.5) = -2
    floor()是向负无穷大舍入，floor(-2.5) = -3；ceil()是向正无穷大舍入
5. 二个int类型的数相除，值为整数，大小为所除所得小数将小数点去掉。即 5/6=0,6/5=1
```

### c++重载

[index](https://blog.csdn.net/liitdar/article/details/80654324)

```text
operator 是C++的一个关键字，它和运算符（如=）一起使用，表示一个运算符重载函数，在理解时可将operator和运算符（如operator=）视为一个函数名。

使用operator重载运算符，是C++扩展运算符功能的方法。使用operator扩展运算符功能的原因如下：

使重载后的运算符的使用方法与重载前一致
扩展运算符的功能只能通过函数的方式实现（实际上，C++中各种“功能”都是由函数实现的）
```

### c++argc,argv

```text
int main (int argc char *argv[])
argc是指执行时参数的个数，程序名算一个参数。
argv是一个数组
```

### c++ &&和\|\|的区别

```text
在c/c++中的&和|是位运算符，和它们处于相同地位的还有<<、>>、^、~。这两个运算符会使得参与运算的参数的每一位都进行运算。例如10和6相与，即1010&0110,得0010，也就是2.

但是&&和||却是逻辑运算符，在它们看来，除了0之外，其他的非零整数都可以看做true，所以如果10和6相与，结果会是true。

有的时候会发现在使用&&的地方可以使用&来替代。在大多数情况下确实都是可以的。这是因为在使用&&的时候，两侧如果都是非0值，那么结果就是true，而在使用&的时候进行相与运算，得到的结果一般也是这样，但是也会有偶然情况：例如10和5相与，即1010&0101，则结果为0，这时候的结果就是不一样的。

总之，它们两个是不一样的。

而且在使用&&的时候，如果第一个就是false，那么就不会再计算第二个参数，因为不管怎样，结果都会是false。这个被称为短路，对于||也是同样的。

总结一下：

&&是逻辑运算符，&是位运算符，在有些时候&&可以被&替代，但是这只能算作巧合。

另外&&还可以短路，在第一个参数是false的情况下，就会发生短路。||在第一个参数是true的情况下，也会发生短路。
```

# 数据结构

## avl(平衡二叉树)树

[平衡因子详解](https://blog.csdn.net/travelerwz/article/details/52186357)

```python
#具有二叉查找树的全部特性。
#每个节点的左子树和右子树的高度差至多等于1。

1、左-左型：做右旋。

2、右-右型：做左旋转。

3、左-右型：先做左旋，后做右旋。

4、右-左型：先做右旋，再做左旋。
```



## 二叉树

### 二叉树的高度和深度

![the_height_and_depth](/home/lyh/桌面/git仓库/daily_note/c++/picture/the_height_and_depth.jpg)

### 前序，中序，后序

```
前序：根节点  左树，右数
中序：左数，根节点，右数
后序：左数，根节点，右数
```

### 广度遍历，深度遍历

```
广度遍历(breadth First )：从左到右，从上到下         //可以用队列
深度遍历: 从左树到右树              //可以用堆栈
```

### 二叉搜索数

```
左子数小于根节点值，右子树值大于根节点数
```

###  字典树

```
利用字典前字母类似的信息，构建树
```

### 哈希树

[index](https://blog.csdn.net/qq_35794278/article/details/80242382)

```
哈希树的节点查找过程和节点插入过程类似，就是对关键字用质数序列取余，根据余数确定下一节点的分叉路径，直到找到目标节点。 
如上图，最小”哈希树(HashTree)在从4G个对象中找出所匹配的对象，比较次数不超过10次。也就是说：最多属于O(10)。在实际应用中，调整了质数的范围，使得比较次数一般不超过5次。也就是说：最多属于O(5)。因此可以根据自身需要在时间和空间上寻求一个平衡点
```

## 红黑树

[index](http://www.sohu.com/a/201923614_466939)

```python
红黑树是二叉查找数的一种变体，当二叉查找树一直偏向一个方向的时候，查找性能退化成线性的，而红黑树可以保持高性能的查找，但是为了维持自平衡，要又额外的开销
#1.节点是红色或黑色。

#2.根节点是黑色。

#3.每个叶子节点都是黑色的空节点（NIL节点）。

#4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

#5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
```



# 操作系统

## $和$

```
$指的是本句程序的开始
$$指的是本句程序开始段的地址
```



## 磁盘结构

![cipan](/home/lyh/桌面/git仓库/daily_note/c++/picture/cipan.gif)

![2012052117213095](/home/lyh/桌面/git仓库/daily_note/c++/picture/2012052117213095.gif)

图中磁盘是一个 3个圆盘6个磁头，7个柱面（每个盘片7个磁道） 的磁盘，图2中每条磁道有12个扇区，所以此磁盘的容量为6*7*12*512字节。

## 文件系统

当标示文件名时，用“.”标示当前目录，用‘..’标示当前工作目录的父目录,当路径以/开头的时候，默认为绝对路径，否则，认为是相对路径。

## cpu

```python
cpu的执行速度为ns级，10亿次/s
内存的速度约为cpu执行速度的百分之1
从硬盘读写的速度约为cpu执行的百万分之一级别的时间
#为什么cpu要有缓存呢？因为程序运行时，某个程序一旦运行，再次运行的几率很大，而且其周围模块被调用的可能性也更大，所以将这些模块放到缓存里。
```

### cpu的开启

```
1.cpu的工作就是运行指令
2.不能保存指令，指令都在内存里
3.第一条指令在0xFFFFFFF0处、
4.执行BIOS的一堆指令，检查内存，硬盘，显卡是否有问题，
5.检查中断向量表
6.INT 0x19，执行0x19对应的一大堆的指令，把磁盘的第一扇区搬到0x7c00处
7.将操作系统从硬盘中唤醒
```

### cpu关注的二样东西

```
工作必备的寄存器
程序寄存器
```

## 静态编译和动态编译

```
    Windows 以两数的形式为应用提供了各种功能 。 这些形式的函数称为 API ( Application Pr吨ramming Inte白白,应用 程序接口)。 例如,Samplel.c 中调用的 MessageBoxO ,它并不是 C 语言的标准函数,而是Windows 提供的 API 的一种 。 MessageBoxO 提供了显示消息框的功能 。Windows 中, API 的目标文件,并不是存储在通常的库文件中,而是存储在名为 DLL ( Dynamic Link Library ) 文件的 特殊库文件中 。 就如Dynamic 这一名称所表示的那样, DLL 文件是程序运行时动态结合的文件
    
    在前面的介绍中,我们提到 MessageBoxO 的目 标文件是存储在lmp。此32.1ib 中的实际上, import32.lib 中仅仅存储着两个信息,一是MessageBoxO 在 user32.dll 这个 DLL 文件中,另一个是存储着 DLL 文件的文件夹信息, MessageBoxO 的目标文件的实体实际上并不存在 。我们把类似于 import32 .1ib 这样的库文件称为 导入库 。
    
    与此相反、存储着目标文件的实体,并直接和 EXE 文件结合的库文件形式称为静 态链接库 J 静态( static =静的)同动态( dynamic =动态的)是相反的意思 。 存储若 sprintfO 的目标文件的 cw32 1ib 就是静态链战库
    
    sprintfO 提供了通过指定恪式把数值转换成字符串的功能 。j国过结合导人库文件,执行时从 DLL 文件 rll 调出的 MessageBoxO萨|数这 一 信息就会和 EXE 文仲ill:行结合 。 这样,链接器链摆 11才就不会
再出现错误消息,从而就可以顺利编写 EXE 文件 。
```



![静态编译和动态编译](/home/lyh/桌面/git仓库/daily_note/c++/picture/静态编译和动态编译.png)

## 事件驱动

比如gui界面，我点击了一个窗口，对应cpu的操作是跳转到那个窗口所在的内存去处理那里的事件。

## 编程中什么是上下文

```
  每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。

你查不到是因为上下文这个东西不是一个具体的东西，上下文在不同的地方表示不同的含义，要感性理解。

context其实说白了，和文章的上下文是一个意思，在通俗一点，我觉得叫环境更好。

....
林冲大叫一声“啊也！”
....

问:这句话林冲的“啊也”表达了林冲怎样的心里？
答:啊你妈个头啊！

看，一篇文章，给你摘录一段，没前没后，你读不懂，因为有语境，就是语言环境存在，一段话说了什么，要通过上下文(文章的上下文)来推断。

子程序之于程序，进程之于操作系统，甚至app的一屏之于app，都是一个道理。

程序执行了部分到达子程序，子程序要获得结果，要用到程序之前的一些结果(包括但不限于外部变量值，外部对象等等)；

app点击一个按钮进入一个新的界面，也要保存你是在哪个屏幕跳过来的等等信息，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。

看这些都是上下文的典型例子，理解成环境就可以，(而且上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是叫的好听叫上下文。。进程中断在操作系统中是有上有下的，不过不给题主说了，免得产生新的问题)

```

## 自旋锁，信号量，互斥锁

```
Semaphore: Use a semaphore when you (thread) want to sleep till some other thread tells you to wake up. Semaphore 'down' happens in one thread (producer) and semaphore 'up' (for same semaphore) happens in another thread (consumer) e.g.: In producer-consumer problem, producer wants to sleep till at least one buffer slot is empty - only the consumer thread can tell when a buffer slot is empty.

Mutex: Use a mutex when you (thread) want to execute code that should not be executed by any other thread at the same time. Mutex 'down' happens in one thread and mutex 'up' must happen in the same thread later on. e.g.: If you are deleting a node from a global linked list, you do not want another thread to muck around with pointers while you are deleting the node. When you acquire a mutex and are busy deleting a node, if another thread tries to acquire the same mutex, it will be put to sleep till you release the mutex.

Spinlock: Use a spinlock when you really want to use a mutex but your thread is not allowed to sleep. e.g.: An interrupt handler within OS kernel must never sleep. If it does the system will freeze / crash. If you need to insert a node to globally shared linked list from the interrupt handler, acquire a spinlock - insert node - release spinlock.
```



# 一篇故事讲懂操作系统抽象概念

```
计算机主机网关的作用是什么？
假设你的名字叫小不点，你住在一个大院子里，你的邻居有很多小伙伴，在门口传达室还有个看大门的李大爷，李大爷就是你的网关。当你想跟院子里的某个小伙伴玩，只要你在院子里大喊一声他的名字，他听到了就会回应你，并且跑出来跟你玩。 
但是你不被允许走出大门，你想与外界发生的一切联系，都必须由门口的李大爷（网关）用电话帮助你联系。假如你想找你的同学小明聊天，小明家住在很远的另外一个院子里，他家的院子里也有一个看门的王大爷（小明的网关）。但是你不知道小明家的电话号码，不过你的班主任老师有一份你们班全体同学的名单和电话号码对照表，你的老师就是你的DNS服务器。于是你在家里拨通了门口李大爷的电话，有了下面的对话：
小不点：李大爷，我想找班主任查一下小明的电话号码行吗？
李大爷：好，你等着。（接着李大爷给你的班主任挂了一个电话，问清楚 
了小明的电话）问到了，他家的号码是211.99.99.99
小不点：太好了！李大爷，我想找小明，你再帮我联系一下小明吧。
李大爷：没问题。（接着李大爷向电话局发出了请求接通小明家电话的请 
求，最后一关当然是被转接到了小明家那个院子的王大爷那里，然后王大 
爷把电话给转到小明家）
就这样你和小明取得了联系。
至于DHCP服务器嘛，可以这样比喻：
你家院子里的居民越来越多了，传达室李大爷那里的电话交换机已经不能满足这么多居民的需求了，所以只好采用了一种新技术叫做DHCP，居民们开机的时候随机得到一个电话号码，每一次得到的号码都可能会不同。
你家门口的李大爷：就是你的网关 
你的班主任：就是你的DNS服务器 
传达室的电话交换机：就是你的DHCP服务器
同上，李大爷和王大爷之间的对话就叫做路由。
另：如果还有个小朋友叫做小暗，他住的院子看门的是孙大爷，因为小暗的院子刚盖好，孙大爷刚来不久，他没有李大爷和王大爷办公室的电话（李大爷和王大爷当然也没有他的电话），这时会有两种情况： 
1、居委会的赵大妈告诉了孙大爷关于李、王两位大爷的电话（同时赵大妈也告诉了李、王关于孙的电话），这就叫静态设定路由 
2、赵大妈病了，孙大爷自己到处打电话，见人就说：“我是小暗他们院子管电话的”，结果被李、王二位听到了，就记在了他们的通讯录上，然后李、王就给孙大爷回了个电话说：“我是小明（小不点）他们院子管电话的”，这就叫动态设定路由
然后有一天小不点要找小暗，结果自然是小不点给李大爷打电话说：“大爷，我找小暗”（这里省略了李大爷去查小暗电话的过程，假设他知道小暗的电话），李大爷一找通讯录：“哦，小暗的院子的电话是孙大爷管着的，要找小暗自然先要通知孙大爷，我可以通知王大爷让他去找孙大爷，也可以自己直接找孙，那当然是自己直接找孙方便了”，于是李大爷给孙大爷打了电话，然后孙大爷又把电话转到了小暗家。
这里李大爷的通讯录叫做路由表。 
李大爷选择是自己直接找孙大爷还是让王大爷帮忙转接叫做路由选择。
李大爷之所以选择直接找孙大爷是有依据的，因为他直接找孙大爷就能一步到位，如果要王大爷转接就需要两步才能完成，这里的“步”叫做“跳数”，李大爷的选择遵循的是最少步骤（跳数）原则（如果他不遵守这个原则，小不点可能就会多等些时间才能找到小暗，最终结果可能导致李大爷因工作不力被炒鱿鱼，这叫做“延时太长，选路原则不合理，换了一个路由器”）
当然，事情总是变化的，小不点和小明吵架了，这些天小不点老是给小暗打电话，小明心里想：“操，他是不是在说我坏话啊？”于是小明决定偷听小不点和小暗的通话，但是他又不能出院子，怎么办呢？小明做了这样一个决定：
首先他告诉自己院里管电话的王大爷说：“你给李大爷打个电话说小暗搬到咱们院子了，以后凡是打给他的电话我来接”，王大爷没反映过来（毕竟年纪大了啊！）就给李大爷打了电话，说：“现在我来管理小暗的电话了，孙已经不管了”，结果李大爷就把他的通讯录改了，这叫做路由欺骗。
以后小不点再找小暗，李大爷就转给王大爷了（其实应该转给孙大爷的），王大爷收到了这个电话就转给了小明（因为他之前已经和小明说好了），小明收到这个电话就假装小暗和小不点通信。因为小明作贼心虚，害怕明天小不点和小暗见面后当面问他，于是通信断了之后，又自己以小不点的名义给小暗通了个电话复述了一遍刚才的话，有这就叫数据窃听
再后来，小不点还是不断的和小暗联系，而零落了小明，小明心里嘀咕啊：“我不能总是这样以小暗的身份和小不点通话啊，外一有一天露馅了怎么办！”于是他想了一个更阴险的招数：“干脆我也不偷听你们的电话了，你小不点不是不给我打电话吗！那我让你也给小暗打不了，哼哼！”，他怎么做的呢？我们来看：
他联系了一批狐朋狗友，和他们串通好，每天固定一个时间大家一起给小暗院子传达室打电话，内容什么都有，只要传达室的孙爷爷接电话，就会听到“打雷啦，下雨收衣服啊！”、“人是人他妈生的，妖是妖他妈生的”、“你妈贵姓”等等，听的脑袋都大了，不听又不行，电话不停的响啊！终于有一天，孙爷爷忍不住了，大喊一声：“我受不了拉！！！！”，于是上吊自杀了！
这就是最简单的DDOS攻击，孙爷爷心理承受能力弱的现象叫做“数据报处理模块有BUG”，孙爷爷的自杀叫做“路由器瘫痪”。如果是我，就会微笑着和他们拉家常，例如告诉他们“我早就听了天气预报，衣服10分钟前已经收好了”或者“那你妈是人还是妖”或者“和你奶奶一个姓”等等，我这种健全的心理叫做“健壮的数据报处理，能够抵御任何攻击”
孙爷爷瘫了之后，小不点终于不再给小暗打电话了，因为无论他怎么打对方都是忙音，这种现象叫做“拒绝服务”，所以小明的做法还有一个名字叫做“拒绝服务攻击”。
小明终于安静了几天，...
几天后，小明的院子来了一个美丽的女孩，名字叫做小丽，小明很喜欢她（小小年纪玩什么早恋！）可是小丽有个很帅的男朋友，小明干瞪眼没办法。当然这里还是要遵循上面的原则：小丽是不能出院子的。那个男的想泡小丽自然只能打电话，于是小明又蠢蠢欲动了： 
还记得王爷爷是院子的电话总管吗？他之所以能管理电话是因为他有一个通讯录，因为同一个院子可能有2个孩子都叫小明，靠名字无法区分，所以通讯录上每一行只有两项：
门牌电话 
一号门 1234567 （这个是小明的） 
二号门 7654321 （这个是小丽的） 
......
王爷爷记性不好，但这总不会错了吧（同一个院子不会有2个“二号门”吧）？每次打电话人家都要说出要找的电话号码，然后通过通讯录去院子里面敲门，比如人家说我找“1234567”，于是王爷爷一比较，哦，是一号门的，他就去敲一号门“听电话”，如果是找“7654321”，那他就找二号门“听电话”。
这里的电话号码就是传说中的“IP地址” 
这里的门牌号就是传说中的网卡的’MAC‘地址（每一块网卡的MAC地址都是不一样的，这是网卡的制造商写死在网卡的芯片中的）
小明心里想“奶奶的，老子泡不到你也别想泡”，于是他打起了王爷爷通讯录的主意，经过细心的观察，周密的准备，他终于发现王爷爷有尿频的毛病（毕竟是老人啊...），终于在一个月黑风高的白天，王爷爷去上厕所了，小明偷偷的摸进传达室，小心翼翼的改了王爷爷的通讯录......
过了几天，小丽的男朋友又给小丽打来了电话，对方报的电话是“7654321”，王爷爷一看通讯录，靠：
门牌电话 
一号门 1234567 （这个是小明的） 
一号门 7654321 （注意：这个原来是小丽的，但是被小明改了） 
......
王爷爷不知道改了啊，于是就去找一号门的小明了，小明心里这个美啊，他以小丽父亲的口吻严厉的教训了那个男的和小丽之间不正当的男女关系，结果那个男的恭恭敬敬的挂了电话。当然小丽并不知道整个事情的发生...
这里小明的行为叫做“ARP欺骗”（因为在实际的网络上是通过发送ARP数据包来实现的，所以叫做“ARP欺骗”），王爷爷的通讯录叫做“ARP表”
这里要注意：王爷爷现在有两个通讯录了，一个是记录每个院子传达室电话的本本，叫做“路由表”，一个是现在说的记录院子里面详细信息的本本，叫做“ARP表”。
有句命言是“人们总是在追求完美的，尽管永远也做不到”（请记住这句话，因为这是一个大名人--也就是我，说的）
王爷爷的制度中有一条是这么写的“每个月要重新检查一下门牌号和电话的对应本（也就是ARP表）”，这个动作叫做“刷新ARP表”，每个月的时间限制叫做“刷新ARP表的周期”。这样小明为了让那个男的永远不能找到小丽，之后每个月都要偷偷改一次那个通讯录，不过这样也是不得不做的事啊！ 
补充一点，小明是很聪明的，如果通讯录（ARP表）被改成了这样：
门牌（MAC）电话（IP） 
一号门 1234567 （这个是小明的） 
二号门 1234567 （注意：这个被小明改了，但是他一时头晕改错了） 
......
就会是计算机就会弹出一个对话框提示“出现重复的IP地址”，最终会导致王爷爷不知所措，于是通知一号门和二号门，你们的电话重复了。这样小丽就知道有人在破坏她的好事，这个现象叫做“骗局被揭穿了”
小不点知道了小明偷听他和小暗的电话，于是就和小暗约定好了密码。小不点在家里把要说的加密了之后告诉小暗。土豆－〉星期三，地瓜－〉请客，笨蛋－〉小不点家。于是小不点告诉小暗：土豆笨蛋地瓜。小明听了？？？不懂。。。。郁闷了。。。这是加密。 
除此之外，小丽也知道了小明改他家的电话号码了。于是王爷爷就登门一个一个把电话和门牌号记下来。并且藏起来不允许外人修改，只能自己有钥匙（密码）。这是ip地址和MAC地址绑定。当有人改了电话号码的时候，就得找王爷爷改。麻烦是麻烦了，但是安全了。不过小明偷偷的把王爷爷的钥匙偷配了一把（盗窃密码成功），于是他还可以修改。这样么，就这样了。
```

